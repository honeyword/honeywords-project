# How to Attack and Generate Honeywords

## Abstract

Honeywords are decoy passwords associated with each user account to timely detect password leakage. The key issue lies in how to generate honeywords that are hard to be differentiated from real passwords. This security mechanism was first introduced by Juels and Rivest at CCS'13, and has been covered by hundreds of media and adopted in dozens of research domains. Existing research deals with honeywords primarily *in an ad hoc manner*, and it is challenging to develop a secure honeyword-generation method and well evaluate (attack) it. In this work, we tackle this problem *in a principled approach*. We first propose four theoretic models for characterizing the attacker <img class="math math-inline" alt="$\mathcal{A}$" src="https://render.githubusercontent.com/render/math?math=%5Cmathcal%7BA%7D&amp;mode=inline">'s best distinguishing strategies, with each model based on a different combination of info available to <img class="math math-inline" alt="$\mathcal{A}$" src="https://render.githubusercontent.com/render/math?math=%5Cmathcal%7BA%7D&amp;mode=inline"> (e.g., public datasets, the victim's personal info and registration order). These theories guide us to design effective experiments with real-world password datasets to evaluate the goodness (flatness) of a given honeyword-generation method.

Armed with the four best attacking theories, we develop the corresponding honeyword-generation method for each type of attacker, by using various representative probabilistic password models. Through a series of exploratory investigations, we show the use of these password models is not straightforward, but requires creative and significant efforts. Both empirical experiments and user-study results demonstrate that our methods significantly outperform prior art. Besides, we manage to resolve several previously unexplored challenges that arise in the practical deployment of a honeyword method. We believe this work pushes the honeyword research toward statistical rigor. 

## Section 1: Two major defects in Honeyindex

At IEEE TDSC'16, Erguler proposed the "Honeyindex" honeyword system to achieve "perfect honeyword-generation". To generate honeywords for a given user <img class="math math-inline" alt="$U_i$" src="https://render.githubusercontent.com/render/math?math=U_i&amp;mode=inline">, Honeyindex directly uses <img class="math math-inline" alt="$k-1$" src="https://render.githubusercontent.com/render/math?math=k-1&amp;mode=inline"> other users' passwords as <img class="math math-inline" alt="$U_i$" src="https://render.githubusercontent.com/render/math?math=U_i&amp;mode=inline">'s honeywords. So the system's honeyword distribution equals the system's password distribution.

### Distinguishing attack

There is a serious security flaw in the Honeyindex system. If some sweetindex is contained in only one user <img class="math math-inline" alt="$U_i$" src="https://render.githubusercontent.com/render/math?math=U_i&amp;mode=inline">'s sweetindex list, the password paired with that sweetindex will be <img class="math math-inline" alt="$U_i$" src="https://render.githubusercontent.com/render/math?math=U_i&amp;mode=inline">'s real password. This enables us to devise a method to definitely distinguish the real password:

1. Find an isolated sweetindex which appears only in *one* user's sweetindex list. It is certain that the password pairing with this isolated sweetindex is this user's real password, because a honeyword will have at least two incoming sweetindexes.
2. Delete all the incoming sweetindexes that pair with <img class="math math-inline" alt="$U_i$" src="https://render.githubusercontent.com/render/math?math=U_i&amp;mode=inline">'s real password, and new isolated sweetindexes will appear.
3. Go to Step 1 until no isolated sweetindex exists.

As the sweetindex of user <img class="math math-inline" alt="$U_i$" src="https://render.githubusercontent.com/render/math?math=U_i&amp;mode=inline">'s real password cannot be contained in the sweetindex lists of users who registered before <img class="math math-inline" alt="$U_i$" src="https://render.githubusercontent.com/render/math?math=U_i&amp;mode=inline">, it will be *only potentially* contained in the sweetindex lists of users that registered later than <img class="math math-inline" alt="$U_i$" src="https://render.githubusercontent.com/render/math?math=U_i&amp;mode=inline">. Thus, the above "peeling-onions style" attack can continue until all users' passwords are figured out. We further find that the attacker can further leverage the sweetindex lists to increase her advantage by the mapping attack (if the system regenerates sweetindexes periodically). For example, if a password is only contained in three users’ sweetindex lists, the attacker can achieve a 1/3 success rate for each of these three users by just guessing this particular password. We generalize this idea by sampling from all possible matchings between users and passwords under sweetindex lists observed: If the pair (<img class="math math-inline" alt="$U_1$" src="https://render.githubusercontent.com/render/math?math=U_1&amp;mode=inline">, <img class="math math-inline" alt="$PW_1$" src="https://render.githubusercontent.com/render/math?math=PW_1&amp;mode=inline">) occurs more frequently than (<img class="math math-inline" alt="$U_1$" src="https://render.githubusercontent.com/render/math?math=U_1&amp;mode=inline">, <img class="math math-inline" alt="$PW_2$" src="https://render.githubusercontent.com/render/math?math=PW_2&amp;mode=inline">) in sampled matchings, then the password <img class="math math-inline" alt="$PW_1$" src="https://render.githubusercontent.com/render/math?math=PW_1&amp;mode=inline"> is more likely to be the real password of the user <img class="math math-inline" alt="$U_1$" src="https://render.githubusercontent.com/render/math?math=U_1&amp;mode=inline">. In this way, our preliminary experimental results show that the claimed <img class="math math-inline" alt="$1/k$" src="https://render.githubusercontent.com/render/math?math=1%2Fk&amp;mode=inline"> flatness on Honeyindex with this mapping attack has increased to 8.0%, 17.3%, and 36.2% when <img class="math math-inline" alt="$k$" src="https://render.githubusercontent.com/render/math?math=k&amp;mode=inline">= 20, 10, and 5, respectively. It is worth noting that, the peeling-onion style attack corresponds to the special case of this mapping attack where there is only one possible mapping between users and passwords. 

Erguler realized that "passwords of newly created accounts would not be used as honeywords", so he suggested regenerating sweetindexes periodically for all users. This not only introduces great computation burdens but another problem arises: most users don't change their passwords periodically. So if <img class="math math-inline" alt="$\mathcal{A}$" src="https://render.githubusercontent.com/render/math?math=%5Cmathcal%7BA%7D&amp;mode=inline">​ gets two password files that are leaked at different time points, the attacker only needs to compare a user's two sweetword lists in these two files, and can have a high confidence that the sweetword which is contained in both sweetword lists is the real password. In reality, many websites don't realize that they have been compromised until several years later. So the attacker has enough time to steal the password file several times until the website realizes this.

Another serious problem will arise if the system regenerates sweetindexes periodically. The passwords are stored in *salted hash* in the (sweetindex, password)–table. So it's hardly *impossible* to keep one user's sweetwords different from each other. If a user has a honeyword that is the same with his password, the position of the honeyword in the sweetword list will be sent to the honeychecker. This will cause a false alarm. To overcome this problem, honeywords should be ensured that they are different from the real password. This can be done when the user registers, but it's hardly impossible when the sweetindex are regenerated periodically: The website does not know the plaintext of user's password, because all passwords have been hashed and salted. This means that Honeyindex falls into a dilemma: Peeling-onions style distinguishing attack (if it doesn't regenerate sweetindexes periodically) or high probability of false alarms (if it does).

### Heavy computational cost

The storage cost of the Honeyindex system is less than the honeyword system, because Honeyindex only stores one hash per user, while the honeyword system needs to store <img class="math math-inline" alt="$k$" src="https://render.githubusercontent.com/render/math?math=k&amp;mode=inline"> hashes per user. But the benefit of the Honeyindex system is come at the cost of heavy computation.

The honeyword system uses the same salt for the user's all <img class="math math-inline" alt="$k$" src="https://render.githubusercontent.com/render/math?math=k&amp;mode=inline"> sweetwords. When a user logs in with password <img class="math math-inline" alt="$pw$" src="https://render.githubusercontent.com/render/math?math=pw&amp;mode=inline">, the website only needs to compute the hash of <img class="math math-inline" alt="$pw$" src="https://render.githubusercontent.com/render/math?math=pw&amp;mode=inline">​ and compare the hash value with the hashes of <img class="math math-inline" alt="$k$" src="https://render.githubusercontent.com/render/math?math=k&amp;mode=inline"> sweetwords. But a user's sweetwords in the Honeyindex system is hashed with different salts, because each salt is uniformly randomly generated, and different accounts is highly likely to have a different salt. Thus, the website needs to compute <img class="math math-inline" alt="$k$" src="https://render.githubusercontent.com/render/math?math=k&amp;mode=inline"> times of salted-hash at worst and <img class="math math-inline" alt="$k/2$" src="https://render.githubusercontent.com/render/math?math=k%2F2&amp;mode=inline"> hashes on average. Generally, it is recommended practice for websites to use a slow, memory-hard hash function (e.g., scrypt and Argon2id) to securely store user passwords. As a result, the authentication time will be wasted at computing <img class="math math-inline" alt="$k$" src="https://render.githubusercontent.com/render/math?math=k&amp;mode=inline"> slow hashes. In all, the computational cost in a login of the Honeyindex system is, on average, <img class="math math-inline" alt="$k/2$" src="https://render.githubusercontent.com/render/math?math=k%2F2&amp;mode=inline">​​ times larger than that of the generic honeyword systems.

## Section 2: Security pitfalls in Akshima et al.'s methods

At IEEE TDSC'18, Akshima et al. proposed three new honeyword methods: two for legacy-UI and one for modified-UI. Due to usability advantages of legacy-UI, we focus on the legacy-UI methods: Evolving password model and user-profile model.

### Review of "evolving password model"

Akshima et al. use a simplified PCFG model to generate honeywords with the *same* probability as the user's real password. In their simplified PCFG model, there are three types of tokens: Letter-strings <img class="math math-inline" alt="$L$" src="https://render.githubusercontent.com/render/math?math=L&amp;mode=inline">, digit-strings <img class="math math-inline" alt="$D$" src="https://render.githubusercontent.com/render/math?math=D&amp;mode=inline"> and special-character-strings <img class="math math-inline" alt="$S_x$" src="https://render.githubusercontent.com/render/math?math=S_x&amp;mode=inline"> of length <img class="math math-inline" alt="$x$" src="https://render.githubusercontent.com/render/math?math=x&amp;mode=inline">. Firstly, one pattern list and three token lists shall be instantiated by using an existing password dataset like 32 million Rockyou. For example, for a password **"loveu4ever@"** in Rockyou, the pattern <img class="math math-inline" alt="$LDS_1$" src="https://render.githubusercontent.com/render/math?math=LDS_1&amp;mode=inline">​ can be inserted into the pattern list the count of <img class="math math-inline" alt="$LDS_1$" src="https://render.githubusercontent.com/render/math?math=LDS_1&amp;mode=inline"> increases by one; the letter-string token **"loveu"** can be inserted into the letter-string list and the count of **"loveu"** increases by one; the digit-string **"4"** can be inserted into the digit-string list and the count of **"4"** increases by one, and so on. To generate honeywords for <img class="math math-inline" alt="$U_i$" src="https://render.githubusercontent.com/render/math?math=U_i&amp;mode=inline">'s real password (say **"123abc!"**): (1) Parse its password pattern to be <img class="math math-inline" alt="$DLS_1$" src="https://render.githubusercontent.com/render/math?math=DLS_1&amp;mode=inline">; (2) Replace this pattern with a pattern of the same probability in the pattern list; (3) Replace the tokens (**"123"**, **"abc"** and **"!"**) with the tokens of the same probability in the three corresponding token lists.

### Defects in the "evolving password model"

There is an inherent flaw in the design idea of evolving-password model. Since user-chosen passwords follow the Zipf's law, the probability <img class="math math-inline" alt="$p_r$" src="https://render.githubusercontent.com/render/math?math=p_r&amp;mode=inline"> of the <img class="math math-inline" alt="$r$" src="https://render.githubusercontent.com/render/math?math=r&amp;mode=inline">th popular password is <img class="math math-inline" alt="$p_r=C \cdot r^s-C\cdot(r-1)^s$" src="https://render.githubusercontent.com/render/math?math=p_r%3DC%20%5Ccdot%20r%5Es-C%5Ccdot%28r-1%29%5Es&amp;mode=inline">, where <img class="math math-inline" alt="$s$" src="https://render.githubusercontent.com/render/math?math=s&amp;mode=inline"> and <img class="math math-inline" alt="$C$" src="https://render.githubusercontent.com/render/math?math=C&amp;mode=inline"> are constants. As <img class="math math-inline" alt="$p_r$" src="https://render.githubusercontent.com/render/math?math=p_r&amp;mode=inline">​ is monotonically decreasing function of the rank <img class="math math-inline" alt="$r$" src="https://render.githubusercontent.com/render/math?math=r&amp;mode=inline">, there will be no password of the sample probability for a given password (including the user <img class="math math-inline" alt="$U_i$" src="https://render.githubusercontent.com/render/math?math=U_i&amp;mode=inline">​'s password <img class="math math-inline" alt="$PW_i$" src="https://render.githubusercontent.com/render/math?math=PW_i&amp;mode=inline">). This is particularly true when the password <img class="math math-inline" alt="$PW_i$" src="https://render.githubusercontent.com/render/math?math=PW_i&amp;mode=inline">​​ is popular. This indicates that generating honeywords with the *same* probability as the user's real password is inherently impossible. This has been detailed when discussing Eq. 3 in the main-text.

What's more, in Sec. IV of our paper we have shown that honeyword methods based on the PCFG model alone are prone to critical defects: its estimation of password probability is not accurate enough, and as a result, the honeywords generated by it can be easily distinguished.

### Review of the "user-profile model"

Akshima et al. realized that "the majority of population uses personal details for choosing password", and proposed to use the user's personal information to generate honeywords. This method is similar to the "evolving password model". The main differences are that: (1) The three token lists also consist of the user's personal information (e.g., name and birthday); (2) Items in the token lists have no frequencies or weights; and (3) It generates <img class="math math-inline" alt="$k-1$" src="https://render.githubusercontent.com/render/math?math=k-1&amp;mode=inline"> honeywords by combining elements randomly drawn from each token list. Note that honeywords (e.g., **"love@9527"**) do not necessarily have the same pattern as the user's real password (e.g., **"123abc!"**), and the only constraint is that all honeywords shall satisfy the password policy of the service.

### Defects in the "user-profile model"

The honeywords generated by this method follow the uniform distribution, because all <img class="math math-inline" alt="$k-1$" src="https://render.githubusercontent.com/render/math?math=k-1&amp;mode=inline">​ honeywords are a random combination of tokens, with the only constraint that honeywords shall satisfy the site's password policy. Therefore they can be easily distinguished by popularity based attacks according to Eq. 3 in our paper. In addition, if the real password includes one token not already in the corresponding token list (which can be re-constructed by the attacker <img class="math math-inline" alt="$\mathcal{A}$" src="https://render.githubusercontent.com/render/math?math=%5Cmathcal%7BA%7D&amp;mode=inline"> according to the Kerckhoffs's principle), <img class="math math-inline" alt="$\mathcal{A}$" src="https://render.githubusercontent.com/render/math?math=%5Cmathcal%7BA%7D&amp;mode=inline"> can easily determine that it is the real password. Last, the random sampling nature of "user-profile model" would greatly underestimate the frequency of user's PII usages, and Eq. 6 in our paper indicates that targeted password guessing models like TarPCFG and TarList would be effective in attacking it.

## Section 3: Security pitfalls and limitations of Superword

At Computers & Security 2019, Guo et al. proposed a new honeyword system called Superword. Basically, Superword works by separating the mapping relation between usernames and passwords. The Superword system stores usernames and password hashes in separate files on the main server, assigns each username and hash a random index upon registration, and places salts and the relationship between users and passwords (represented by random index pairs) on the honeychecker. Additional honeypots are used to detect data compromise. Guo et al. claim that Superword achieves <img class="math math-inline" alt="$1/n$" src="https://render.githubusercontent.com/render/math?math=1%2Fn&amp;mode=inline"> flatness (<img class="math math-inline" alt="$n$" src="https://render.githubusercontent.com/render/math?math=n&amp;mode=inline"> is the number of users) and offers strong DoS resistance.

### Security analysis

We show that Superword cannot achieve <img class="math math-inline" alt="$1/n$" src="https://render.githubusercontent.com/render/math?math=1%2Fn&amp;mode=inline">​ flatness and is vulnerable to DoS attacks. First, Superword itself does not prevent a correct password from being accepted. Therefore, we can derive a very crude bound of flatness by considering an attacker that only submits the most common password. Since users tend to choose weak passwords, the attacker's winning probability is already much greater than <img class="math math-inline" alt="$1/n$" src="https://render.githubusercontent.com/render/math?math=1%2Fn&amp;mode=inline"> (about 1.45% in Dodonew dataset). Second, Guo et al. suggested using the same number of honeypot accounts as real accounts in Superword, but the excessive use of honeypots makes the system vulnerable to DoS attacks. For example, as users like to reuse their usernames across websites, it is reasonable to assume that attackers can hit <img class="math math-inline" alt="$10^4$" src="https://render.githubusercontent.com/render/math?math=10%5E4&amp;mode=inline"> real usernames. Since it should be difficult to distinguish honeypot usernames from real usernames, we can also expect that the attackers would hit at least <img class="math math-inline" alt="$10^3$" src="https://render.githubusercontent.com/render/math?math=10%5E3&amp;mode=inline"> honeypot usernames. However, the Superword system raises an alarm soon as *three* honeypot usernames are logged (attackers do not need to provide correct passwords). Furthermore, the fact that attackers can trigger an alarm solely by submitting honeypot usernames limits the applicability of Superword: it would not be feasible to deploy Superword in social media or web forums, where usernames are often considered public or semi-public. 

### Larger communication overhead

Superword brings extra communication overhead compared to Juels-Rivest style honeyword systems. Superword requires two sequential queries to honeychecker for a normal login, while Juels-Rivest honeyword systems need only one. A non-sweetword login (probably caused by typos or online attacks) in Superword still requires one query to the honeychecker to fetch the salt; however, Juels-Rivest honeyword systems can reject such requests immediately on the main server. This overhead can be especially demanding when the honeychecker is outsourced or placed away from the server.

### Stress on honeychecker

 Superword violates the design principles of honeywords by placing too much stress on the honeychecker. First, the Juels-Rivest honeychecker provides a failover mode, so the system can still work when the honeychecker fails by promoting all sweetwords to be passwords. By contrast, the honeychecker becomes a single point of failure in Superword, because salts are only stored in the honeychecker. Second, the Juels-Rivest honeychecker is designed to manage a minimal amount of secret states (<img class="math math-inline" alt="$n\log{k}$" src="https://render.githubusercontent.com/render/math?math=n%5Clog%7Bk%7D&amp;mode=inline"> bits), but Superword maintains much more secret states in the honeychecker (about <img class="math math-inline" alt="$n\log{n} + 128n$" src="https://render.githubusercontent.com/render/math?math=n%5Clog%7Bn%7D%20%2B%20128n&amp;mode=inline"> bits using bcrypt), making it more vulnerable to attacks. Third, an active attacker that controls the Juels-Rivest honeychecker still needs to submit valid sweetwords to fool the server. However, such attacker against Superword can use the her own password to log into any account; she only needs to modify the honeychecker to always provide her own salt to the server and return **true** to all check queries.

### Honeyword or distributed password storage?

Superword is presented as an improvement of honeywords. However, we see from the above discussion that Superword requires more drastic changes than honeywords and gives rise to new issues. In fact, Superword does not detect password compromise as honeyword systems do, because attackers cannot revert a single password hash without compromising the honeychecker. We argue that Superword has more in common with distributed password storage schemes. For example, Superword can be seen as a simplification of Brainard et al.'s scheme [USENIX SEC'03]: Separating hash and salt can be viewed as a raw way of splitting secrets; the use of random indexes is also similar to the pseudonyms on Brainard et al.'s red server. Superword does not use equality testing as Brainard et al. did since it trusts both the server and the honeychecker, but as shown above, this can be exploited by active attackers. Further discussions are out of the scope of this paper.

*[USENIX SEC'03]: J. G. Brainard, A. Juels, B. Kaliski, and M. Szydlo, "A new two-server approach for authentication with short secrets,” in Proc. USENIX SEC 2003, pp. 201–214.*
